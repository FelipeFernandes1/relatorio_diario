# -*- coding: utf-8 -*-
"""eelatorio_diario

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VxNWchHqMz6a4edX9MU0rvuKPrU9Eu05
"""

# app.py
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
from fpdf import FPDF
from matplotlib.dates import DateFormatter

# Funções necessárias (copie e cole as funções do seu código aqui)
def get_last_date(df, status, status_hugme, pagina):
    filtered_df = df[
        (df['Status'] == status) &
        (df['Status Hugme'] == status_hugme) &
        (df['Página'] == pagina)
    ]
    if not filtered_df.empty:
        return filtered_df['Data Reclamação'].min().strftime('%d/%m')
    else:
        return 'Não há'

def plot_pending_cases(df, paginas):
    pending_data = {
        "Página": [],
        "Sem atribuição": [],
        "Atribuído": []
    }

    for pagina in paginas:
        df_pendentes = df[(df['Status Hugme'] == 'Novo') & (df['Página'] == pagina)]
        sem_atribuicao = df_pendentes[df_pendentes['Status'] == 'Sem atribuição'].shape[0]
        atribuido = df_pendentes[df_pendentes['Status'] == 'Atribuído'].shape[0]

        pending_data["Página"].append(pagina)
        pending_data["Sem atribuição"].append(sem_atribuicao)
        pending_data["Atribuído"].append(atribuido)

    df_pending = pd.DataFrame(pending_data)
    df_pending.set_index('Página', inplace=True)
    df_pending['Total'] = df_pending['Sem atribuição'] + df_pending['Atribuído']
    df_pending_sorted = df_pending.sort_values(by='Total', ascending=True)

    colors = ['#808080', '#ec7b20']
    fig, ax = plt.subplots(figsize=(9, 2))
    bars = df_pending_sorted[['Atribuído', 'Sem atribuição']].plot(kind='barh', stacked=True, ax=ax, width=0.9, color=colors)

    ax.tick_params(axis='x', labelsize=10)
    ax.tick_params(axis='y', labelsize=10)
    ax.set_ylabel('')

    for i, (sem_atribuicao, atribuido) in enumerate(zip(df_pending_sorted['Sem atribuição'], df_pending_sorted['Atribuído'])):
        total = sem_atribuicao + atribuido
        if total >= 15:
            ax.annotate(f'{atribuido}', xy=(atribuido, i), xytext=(-10, 0), textcoords='offset points', ha='center', va='center', fontsize=10, color='white')
            ax.annotate(f'{sem_atribuicao}', xy=(atribuido + sem_atribuicao, i), xytext=(-10, 0), textcoords='offset points', ha='center', va='center', fontsize=10, color='black')

    plt.tight_layout()
    plt.savefig('casos_pendentes.png')
    plt.close()

def plot_cumulative_daily_average(df, paginas):
    plt.figure(figsize=(9, 4))
    max_y_value = 0
    markers = ['o', 's', '>', '_']
    color = '#5800d9'

    for i, pagina in enumerate(paginas):
        df_pagina = df[df['Página'] == pagina].set_index('Data Reclamação').resample('D').size()
        dates = df_pagina.index
        values = df_pagina.values

        if len(values) == 0:
            continue

        cumulative_sum = np.cumsum(values)
        cumulative_days = np.arange(1, len(values) + 1)
        cumulative_average = cumulative_sum / cumulative_days

        plt.plot(dates[:len(cumulative_average)], cumulative_average, label=f'{pagina}', linewidth=2, color=color, marker=markers[i % len(markers)])

        for date, avg in zip(dates[:len(cumulative_average)], cumulative_average):
            if avg >= 5:
                plt.text(date, avg + 1, f'{int(avg)}', fontsize=8, ha='center', va='bottom', color='#5800d9')

        if cumulative_average.max() > max_y_value:
            max_y_value = cumulative_average.max()

    if max_y_value > 0:
        ylim_upper = max_y_value * 1.4
        plt.ylim(0, ylim_upper)

    plt.legend(loc='upper right', fontsize=8, framealpha=0.6)
    plt.gca().xaxis.set_major_formatter(DateFormatter('%d/%m'))
    plt.xticks(fontsize=10)
    plt.yticks(fontsize=10)
    plt.tight_layout()
    plt.savefig('media_diaria_acumulada.png')
    plt.close()

def generate_pdf_report(data_ultimas_datas, img_path, media_diaria_acumulada_img_path):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", style='B', size=16)
    pdf.cell(200, 10, txt=f"Relatório diário", ln=True, align="C")
    pdf.set_font("Arial", size=10)
    pdf.cell(200, 10, txt=f"Casos criados entre {data_ultimas_datas[0]} e {data_ultimas_datas[1]}", ln=True, align="C")

    pdf.set_font("Arial", size=13)
    title_text = "Casos pendentes de resposta pública"
    pdf.cell(0, 10, txt=title_text, ln=True, align="C")
    pdf.image(img_path, x=4, y=pdf.get_y() + -13, w=190)
    pdf.ln(30)

    title_text = "Últimas datas dos casos pendentes"
    pdf.cell(0, 10, txt=title_text, ln=True, align="C")
    col_width = 150 / 3
    pdf.set_font("Arial", style='B', size=10)
    pdf.cell(col_width, 7, txt="Página", border=1, align="C")
    pdf.cell(col_width, 7, txt="Sem atribuição", border=1, align="C")
    pdf.cell(col_width, 7, txt="Atribuído", border=1, ln=True, align="C")

    pdf.set_font("Arial", size=10)
    for item in data_ultimas_datas:
        pagina, datas = item.split(" Sem atribuição: ")
        sem_atribuicao, atribuido = datas.split(", Atribuído: ")

        pdf.cell(col_width, 7, txt=pagina, border=1, align="C")
        pdf.cell(col_width, 7, txt=sem_atribuicao, border=1, align="C")
        pdf.cell(col_width, 7, txt=atribuido, border=1, ln=True, align="C")

    pdf.ln(5)
    pdf.set_font("Arial", size=13)
    title_text = "Incoming(média diária acumulada)"
    pdf.cell(0, 10, txt=title_text, ln=True, align="C")
    pdf.image(media_diaria_acumulada_img_path, x=8, y=pdf.get_y() - 2, w=190)
    pdf.output("relatorio.pdf")

# Início do aplicativo Streamlit
st.title("Análise de Chamados")
st.write("Faça upload de até quatro arquivos Excel:")

# Upload de arquivos
uploaded_files = st.file_uploader("Escolha arquivos Excel", type=["xlsx"], accept_multiple_files=True)

if uploaded_files:
    # Carregando os dataframes
    dfs = []
    for uploaded_file in uploaded_files:
        df = pd.read_excel(uploaded_file, header=3)
        dfs.append(df)

    # Verificando tamanhos dos dataframes
    for i, df in enumerate(dfs):
        st.write(f"Tamanho da base {i + 1}: {len(df)}")

    # Unindo os dataframes
    df_geral = pd.concat(dfs, axis=0)
    df_geral.reset_index(drop=True, inplace=True)
    df_geral['Data Reclamação'] = pd.to_datetime(df_geral['Data Reclamação'])
    df_geral['Página'] = ['Pay', 'Classificados', 'Zap', 'Viva'] * (len(df_geral) // 4 + 1)
    df_geral = df_geral.head(len(df_geral))

    # Tratamento da coluna "atribuído para"
    df_geral['Status'] = df_geral['Atribuido Para'].fillna('Sem atribuição').replace({'Sem atribuição': 'Sem atribuição', 'Atribuído': 'Atribuído'})

    # Gerando os gráficos
    paginas = ['Pay', 'Classificados', 'Zap', 'Viva']
    plot_pending_cases(df_geral, paginas)
    plot_cumulative_daily_average(df_geral, paginas)

    # Exibindo gráficos
    st.write("### Gráfico de Casos Pendentes")
    st.image('casos_pendentes.png')

    st.write("### Gráfico de Média Diária Ac